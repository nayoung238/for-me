## Paging

- External fragmentation: 프로세스의 크기와 고정된 사이즈 차이에서 생기는 낭비
- Internal fragmentation: 프로세스가 끝나고 생긴 빈 공간과 새로 들어갈 프로세스 사이즈 차이에서 생기는 낭비

고정 분할은 내부 단편화가, 가변 분할은 외부 단편화가 생겨 메모리를 효율적으로 이용하지 못한다.<br>

Paging은 작업 크기가 동일한 페이지로 나눠 처리하는 방법으로 **프로세스는 Page 단위, 메인 메모리는 Page Frame 단위**인 동일한 크기(4KB)로 나눠 페이지를 프레임에 할당하는 방식이다. 이 방식은 **외부 단편화로 인한 메모리 낭비를 없애고 4KB 미만의 내부 단편화로 인한 낭비만 존재**한다.<br>

프로세스를 실행시키기 위해 Page를 Page Frame에 올리는데 4KB로 크기가 같기 때문에 외부 단편화가 생기지 않는다. 하지만 프로세스를 4KB로 분할하면 마지막 부분이 4KB이하일 경우 내부 단편화가 생기지만 4KB미만의 낭비이다.<br>

Page와 Page Frame 단위의 크기를 더 줄이면 내부 단편화를 줄일 수 있겠지만, Page가 어느 Frame에 할당되었는지 관리하는 Page Table의 부담이 커진다.

### 인위적 영속성

같은 프로세스의 여러 Page가 메모리로 올라갈 경우 연속적인 Page Frame에 할당된다고 보장할 수 없다. 한 프로세스의 페이지를 메인 메모리의 여러 위치에 분산 적재하며, 이는 Page table을 통해 적재된 위치를 찾을 수 있기 떄문에 운영체제의 페이지 관리 부담이 커진다.

<br>

## Page table

- 프로세스마다 Page table을 가지고 있으며 Page table은 여러 PTE(Page table entry)로 구성
- PTE(Page table entry)는 특정 페이지의 상태를 저장
  - 어떤 Page frame에 존재하는지, 메모리 또는 디스크에 존재하는지, 수정되었는지 등의 정보를 확인할 수 있음
- 메모리의 page frame에 할당되므로 여러 PTE는 연속적이며, 1개의 Page frame보다 크기가 클 경우 다른 Page frame을 할당
- 즉, Page table로 각 Page가 어느 Page frame에 할당되었는지 체크 (Frame 번호를 가지고 있음)
- 그렇기 떄문에 한 프로세스의 여러 Page는 연속적인 Page frame에 할당될 필요 없음

<br>

## Address translation

![png](/_operating-system/_img/address_translation.png)

- Logical address(논리 주소)란 프로그램의 시작위치로부터 상대적인 값으로, MMU가 논리주소를 물리주소로 변환
- 이처럼 MMU의 도움을 받아 주소를 변경하는 것을 **Dynamic relocation**이라고 함
<br>

32비트 시스템에서 페이지 프레임의 크기가 4KB일 때, 4GB 메모리에 접근하기 위해 필요한 테이블의 크기를 구해보며 논리 주소를 물리 주소로 변경하는 과정을 이해해보자.<br>

- 페이지 프레임의 크기가 4KB라는 의미는 페이지 프레임을 나타내기 위해 12비트가 필요하다는 의미이다. (2^12 = 4096)
  - 이는 오프셋에 필요한 비트가 12 비트라는 의미이다. 오프셋은 페이지 프레임 내의 상대적인 위치를 나타내기 떄문이다.
- 4GB(32비트) 메모리에서 생성할 수 있는 페이지 프레임의 개수는 2^(32 - 12) = 2^20 개이다.
  - 이는 페이지 프레임 번호에 필요한 비트가 20 비트라는 의미이다.
<br>

페이지 테이블은 2^20개의 페이지 프레임의 정보를 갖고 있으며, 2^20개의 PTE(Page table entry)를 가지고 있다는 의미와 같다.
이 때 entry의 크기가 2^2 byte라면 페이지 테이블의 크기는 2^20 * 2^2 = 2^22 byte 라는 답을 구할 수 있다.<br>

32비트 중 12비트는 오프셋으로 사용중이니 나머지 20는 페이지 프레임 색인을 나타내기 위해 사용된다.
페이지 테이블에서 20비트를 이용해 해당되는 색인을 찾아가면 **메모리의 테이블 프레임 기준 주소가 존재**한다. 
페이지 테이블의 PTE를 통해 찾아낸 **메모리의 테이블 프레임 기준 주소와 기존 12비트로 표현한 오프셋을 합친 결과가 물리 주소**이다.<br>

가상주소를 물리주소로 바꿀 때마다 위 과정이 일어나는데 OS가 처리하면 느리므로 MMU가 처리한다.

<br>

## Offset

![png](/_operating-system/_img/offset.png)

- Page의 크기는 offset에 비례
- offset 12비트이면 Page 크기 2^12 = 4096 = 4KB
- 반대로 Page 크기가 4KB이면 Offset은 12bit 임을 파악할 수 있음
- 오프셋은 페이지 프레임의 내의 상대적인 위치를 나타내는 주소이므로 페이지 프레임 크기보다 작아야 함
