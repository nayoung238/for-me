# Multi-Level Feedback Queue (MLFQ)

Round Robin(RR, Time slicing)은 응답시간을 단축시키지만 service time인 긴 프로세스의 경우 최악의 turn around time(반환 시간)을 얻게될 수 있다.
이를 해결하고자 나온 MLFQ는 대화식 사용자에게 응답 시간을 최소화해 빠른 시스템인 것처럼 느끼게 해준다.

<br>

## 동작 방식

- 여러개의 큐를 사용하며 각각의 큐에게 우선순위 지정
- 1개의 큐에는 여러 프로세스가 존재할 수 있음
- 같은 큐에 있는 여러 프로세스는 우선순위가 모두 동일하며 FIFO로 동작
- 여러 큐 중 우선순위가 높은 큐부터 수행

프로세스에게 우선순위 큐를 지정해주는 방식은 ```I/O bound job``` 과 ```CPU bound job``` 이 있다.

- I/O bound job : I/O 를 하면서 다른 프로세스에게 CPU를 양보하면 해당 프로세스의 우선순위를 올려준다. 현대 OS에서 사용하는 방식이다.
- CPU bound job : CPU를 집중적으로 사용해 차지하는 시간이 길어지는 프로세스의 우선순위를 낮춘다.

우선 순위가 높은 큐에 있는 경우 빠르게 처리되지만, CPU를 차지할 수 있는 시간이 짧다.<br>
반대로 우선 순위가 낮은 큐에 있는 경우 CPU를 차지할 수 있는 시간이 길어져 오래 연산할 수 있지만, 우선순위가 낮기 때문에 CPU를 차지할 확률이 낮다.

<br>

## Rule

- rule 1 : 우선순위가 높은 것 부터 수행
- rule 2 : 같은 우선순위라면 FIFO 적용
- rule 3 : 시스템에 들어갈 떈 해당 프로세스의 수행시간을 알 수 없어 일단은 가장 높은 우선순위를 부여
- rule 4a : 주어진 TQ을 다 사용하면 우선순위가 낮아져 다음 큐로 이동
- rule 4b : 주어진 TQ를 다 사용하기 전에 CPU를 양도하면 우선순위가 유지

<br>

## Rule 4b로 인해 starvation 상태 발생

대화형 작업은 CPU를 자주 양도하기 때문에 우선순위가 유지된다.
Rule 4b 의 특성을 이용해 TQ의 99%만 사용하고 CPU를 양도하면 높은 우선순위를 유지할 수 있다.
이처럼 프로그램을 재작성하여 scheduler를 자신에게 유리하도록 동작하게 하는 것을 Gaming 조작이라고 한다.<br>

이런 조작으로 인해 낮은 우선순위에 존재하며 CPU를 많이 필요한 프로세스가 수행되지 못하는 문제가 발생한다. 이런 프로세스를 대화형 작업으로 바꿔도 이미 낮은 우선순위에 있기 때문에 문제가 해결되지 않는다.

<br>

## Rule 4b로 발생하는 문제를 해결하기 위한 Boosting

일정 시간이 지나면 시스템의 모든 작업을 최상위 큐로 옮긴다. 이로 인해 starvation 현상을 해결하고, CPU bound 작업이 대화형이나 I/O 작업으로 바뀌는 경우 우선 순위가 다시 올라가면서 CPU를 차지하는 가능성이 높아진다.<br>

하지만 gaming의 문제는 해결할 수 없다. voodoo constants(black magic)는 얼마나 자주 우선순위에 올리는지 나타내는 상수이다. voodoo constants이 너무 크면 starvation 현상이 그대로, 너무 작으면 I/O 위주 작업과 대화형 작업이 분리해 적절한 접점을 찾아야 한다.<br>

결국 boosting도 rule 4b의 문제를 완전히 해결하지 못한다.

<br>

## Gaming Tolerance

프로그램을 재작성하여 scheduler를 자신에게 유리하게 동작하는 gaming 조작을 막는 것을 Gaming tolerance라고 한다.<br>

Round Robin(RR, Time slicing)은 응답시간을 단축시키지만 service time인 긴 프로세스의 경우 최악의 turn around time(반환 시간)을 얻게되는 문제는 CPU를 중간에 양도할 수 있다는 점에서 발생하는 문제다. 그러므로 해당 프로세스가 주어진 TQ를 다쓰면 CPU를 몇번 양도했는지 상관 없이 우선 순위를 낮춰 다음 큐로 이동시켜 Gaming 조작을 막을 수 있다.<br>

하지만 모든 프로세스가 사용한 TQ를 계산해야 하므로 overhead가 발생하는 새로운 문제가 생긴다. 

