## ACID

### Atomicity 원자성

- 트랜잭션 내 모든 연산이 원자적으로 처리되어 모두 커밋 또는 모두 취소되는 것을 보장
- 단일 환경: @Transactional (proxy 기반 AOP로 동작)
- 분산 환경: 한 요청에 대한 여러 트랜잭션으로 분리 (2PC, saga 패턴)

### Consistency 일관성

- 데이터베이스의 무결성 제약
- ‘1부터 10까지의 값만 가질 수 있다’ 같은 약속
- 비동기식으로 복제되는 시스템, ACID, CAP 정리 등 여러 상황에서 일관성의 의미가 조금씩 다름

### Isolation 격리성

- 각 트랜잭션은 데이터베이스에서 유일하게 실행되는 트랜잭션인 것처럼 동작할 수 있음을 의미 -> 여러 동시성 문제 방지
- MySQL은 MVCC 기법으로 쓰기 작업과 읽기 작업이 서로 막지 않고 처리 가능
- MVCC: 락을 사용하지 않고 특정 트랜잭션에게 UNDO 영역에 존재하는 여러 버전 중 일관된 버전만 제공
    
### Durability 지속성

- 트랜잭션이 커밋되면 그 결과는 영구적으로 반영되어야 함
- 하지만 현실에서 완벽한 지속성 보장은 어려움 (손실 가능성 존재)

<br>

## 트랜잭션 격리 수준

### Level 0: Read Uncommitted

- 커밋되지 않은 데이터 읽기 가능
- 커밋되지 않은 데이터로 새로운 데이터 생성 시 발생할 수 있는 문제까지 생각한다면 해당 격리 수준은 위험 

### Level 1: Read committed

- 커밋된 데이터만 read
- 읽기 작업은 undo 영역에 있는 커밋된 데이터 제공
- MySQL 해당 격리 수준에서 gap, next key lock 적용되지 않아 phantom read 현상 발생할 수 있음
- 가끔 읽기 작업을 read committed 격리 수준으로 내려 진행하시는 분들이 계셨는데, 개인적인 생각으로 읽기 작업엔 락이 필요하지 않아 격리 수준을 내릴 필요가 없다고 생각...

### Level 2: Repeatable Read

- MySQL에서는 MVCC 메커니즘을 통해 트랜잭션은 같은 버전의 데이터를 제공해 비반복 읽기 현상을 방지
- MVCC 기법은 읽기, 쓰기 작업이 서로 막지 않아 빠른 처리 가능 
- MySQL 해당 격리 수준부터 gap, next key lock 적용되어 Phantom read 현상을 방지하나, 쓰기 쿼리나 락을 사용한 읽기 쿼리를 잘못 작성하면 많은 부분이 잠길 수 있음
  - Phantom read: 한 트랜잭션에서 여러번 조회 시 새로운 데이터가 추가되거나 제거된 상태
  - Write Skew: 서로 다른 행에 대해 독립적인 변경 발생 -> 이 과정에서 정합성이 깨지는 문제, Phantom read 현상 때문에 쓰기 스큐 발생할 수 있음

### Level 3: Serializable
- 공유 자원에 대한 트랜잭션 순차 처리해 일관성 제공
- 읽기 작업도 S-Lock을 획득하기 위해 대기 -> 동시성 저하
- MySQL에서는 next key lock으로 phantom read 현상을 해결하고 있어, 해당 격리 수준을 사용할 일이 거의 없지 않을까 추측