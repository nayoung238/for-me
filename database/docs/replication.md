### 비동기 Replication (Real MySQL 8.0 2권 참고)

replica 서버에는 바이너리 로그를 소스 서버에게 요청
- 완전한 push도, 단순한 pull 도 아님 (gpt 내용, 공식 문서에서 push, pull 내용 찾지 못함)
- 소스 서버는 replica가 연결을 먼저 요청해야만 binary log 보내기 시작 (완전한 push X)
- replica가 주기적으로 요청하는 것이 아니라 끊기지 않는 한 지속적인 로그 스트리밍을 받음 (streaming pull)

기본 복제 방식은 단방향 비동기로 소스 서버는 레플리카에 변경 이벤트가 잘 전달 및 적용되었는지 파악하지 않음
- 이는 소스 서버와 레플리카 서버의 장애가 전파되지 않다는 장점이지만,
- 데이터 일관성이 충분히 깨질 가능성 있음

<br>

### 복제 과정

레플리카 서버가 연결되면 소스 서버는 바이너리 로그 덤프 스레드 생성해 바이너리 로그 전송
- 레플리카 서버의 Replication IO 스레드가 바이러니 로그를 받아 릴레이 로그에 기록
- 레플리카 서버의 Replication SQL 스레드가 릴레이 로그를 읽고 디스크에 기록

<br>

### 반동기 복제

- 변경 이벤트를 레플리카 서버가 릴레이 로그에 기록 후 소스 서버로 응답
- 소스 서버는 이 응답을 받으면 트랜잭션을 커밋하고 클라이언트에게 결과 반환
- 완전 비동기 방식보다는 이벤트 전달을 보장할 수 있지만, 속도 느려짐
- 또한, 변경 이벤트가 전달되었음을 보장하는 것이지, 레플리카 서버의 데이터 파일에 적용되었음을 보장하는 것이 아님
  - ~~이처럼 데이터 일관성을 유지하는 것은 어려운 문제 (예를 들어 다중 DB에서 Phantom 현상을 어떻게 해결할 것인가)~~ 라고 생각했지만,
  - 공식 문서에서 '반동기 복제는 커밋이 성공적으로 반환되면 데이터가 최소 두 곳에 존재해 데이터 무결성을 제공한다'라고 작성된 것을 보면 릴레이 로그가 데이터 파일에 적용되는 것을 내부에서 알아서 보장하는 듯
  - https://dev.mysql.com/doc/refman/8.0/en/replication-semisync.html

<br>

### 원격 복제

- 소스 서버 미국, 복제 서버 한국 & 일본 (온프레미스 환경이라 가정)
- 원격 복제도 기본 설정으로 가능
- 대신 latency 발생할 수 있음 (최종적 일관성)
- 인터넷망 사용료 발생
  - 리플리케이션 구조를 최적화하지 않으면 2-3년 전부터 논란이 되었던 CP-ISP 간 망 사용료 문제로 이어지지 않을까... 개인적인 생각
  - 상위 ISP가 같은 리전에서는 계층형 복제 구조를 적용하거나
  - MySQL에 바이러니 로그 압축 기능이 있던데 사용하거나 (정확한 해결책인지 모르겠음)

<br>

### 리더 선출 및 쓰기 폐기

- 리더에서 발생한 쓰기가 replica로 동기화되지 못하고 리더 다운
- 다운된 리더의 최신 데이터 변경 사항을 가진 replica가 새로운 리더
- 이때 반영하지 못한 쓰기를 단순 폐기하면 고객 만족도 당연히 떨어짐
- 또한 다운된 이전 리더가 활성화되어 다시 리플리케이션 구조에 추가되었을 때 충돌 발생할 수 있음
  - 이전 리더에서 PK 15, 16 생성 / 현재 리더 PK 14 까지 동기화한 상태에서 리더 승격 후 새로운 15, 16 생성
  - 깃허브 사례 https://github.blog/2012-09-14-github-availability-this-week/